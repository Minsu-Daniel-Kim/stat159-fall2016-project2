index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
# 10-fold cross validation
# train the model
train_control<- trainControl(method="cv", number=10)
credit.train %>% nrow()
model.lm <- train(Balance~., data=credit, trControl=train_control, method="lm")
model.lm
SST <- function(y, y_mean) {
sum((y - y_mean) ^ 2)
}
y = c(1,2,3)
y_mean = mean(y)
y = c(1,2,3)
y_mean = mean(y)
sst <- SST(y, y_mean)
sst
y_mean
y - y_mean
(y - y_mean) ^^ 2
(y - y_mean) ^ 2
sum((y - y_mean) ^ 2)
library(testthat)
library(testthat)
source("code/functions/evaluation.R")
context("Test for ols regression")
test_that("Sum of Squared Total", {
y = c(1,2,3)
y_mean = mean(y)
expect_equal(SST(y, y_mean), 2)
})
test_that("Sum of Squared Total", {
y = c(1,2,3)
y_mean = mean(y)
expect_equal(SST(y, y_mean), 2)
})
test_that("Sum of Squared Total", {
y = c(1,2,3, 4)
y_mean = mean(y)
expect_equal(SST(y, y_mean), 2)
})
library(testthat)
source("code/functions/evaluation.R")
context("Test for ols regression")
test_that("Sum of Squared Total", {
y = c(1,2,3)
y_mean = mean(y)
expect_equal(SST(y, y_mean), 2)
})
test_that("regression sum of squares", {
y = c(1,2,3)
y_mean = mean(y)
expect_equal(SSR(y, y_mean), 2)
})
library(testthat)
source("code/functions/evaluation.R")
test_that("regression sum of squares", {
y = c(1,2,3)
y_mean = mean(y)
expect_equal(SSR(y, y_mean), 2)
})
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
test_that("r-squared", {
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
expect_equal(rsquared(y, y_estimate), 1)
})
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
expect_equal(rsquared(y, y_estimate), 1)
rsquared <- function(y, y_estimated) {
y_mean = mean(y)
sst <- SST(y, y_mean)
ssr <- SSR(y, y_estimated)
return(ssr/sst)
}
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
expect_equal(rsquared(y, y_estimate), 1)
library(testthat)
source("code/functions/evaluation.R")
test_that("r-squared", {
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
expect_equal(rsquared(y, y_estimate), 1)
})
rsquared <- function(y, y_estimated) {
y_mean = mean(y)
sst <- SST(y, y_mean)
ssr <- SSR(y_estimated, y_mean)
return(ssr/sst)
}
test_that("r-squared", {
y <- c(1,2,3)
y_estimate <- c(1, 2, 3)
expect_equal(rsquared(y, y_estimate), 1)
})
source("code/functions/evaluation.R")
source("code/functions/evaluation.R")
model.summary <- summary(model.lm)
model.summary
model.lm
model.lm$results
model.lm$pred
model.lm.pred <- predict(model.lm, credi.test)
model.lm.pred <- predict(model.lm, credit.test)
model.lm <- train(Balance~., data=credit, trControl=train_control, method="lm")
model.lm.pred <- predict(model.lm, credit.test)
model.lm.summary <- summary(model.lm)
model.lm.pred
rsquared(credit.test$Balance, model.lm.pred)
library(caret)
library(dplyr)
source("code/functions/evaluation.R")
# import preprocessed credit file
credit <- read.csv("data/scaled-credit.csv")
# split data set into 80% (training & validation) / 20% (testing)
set.seed(1000)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
# train the model
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="lm")
model.lm.pred <- predict(model.lm, credit.test)
model.lm.summary <- summary(model.lm)
rsquared(credit.test$Balance, model.lm.pred)
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="lm")
model.lm
model.lm.pred <- predict(model.lm, credit.test)
model.lm.summary <- summary(model.lm)
rsquared(credit.test$Balance, model.lm.pred)
rsquared <- function(y, y_estimated) {
y_mean = mean(y)
sst <- SST(y, y_mean)
ssr <- SSR(y_estimated, y_mean)
return(ssr/sst)
}
# train the model
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="lm")
model.lm.pred <- predict(model.lm, credit.test)
model.lm.summary <- summary(model.lm)
rsquared(credit.test$Balance, model.lm.pred)
model.lm.summary
model.lm
model.lm$results
model.lm.summary
model.lm
model.lm.pred <- predict(model.lm, credit.test)
model.lm.pred
model.lm.pred
predict
model.lm.pred
model.lm.summary
model.lm$results
model.lm$results
plot(model.lm$results)
train_control
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.lm
?lm
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.lm.pred <- predict(model.lm, credit.test)
model.lm.pred
model.lm
model.lm$results
model.lm <- train(Balance~., data=credit.train, trControl=train_control, method="lm")
model.lm.pred <- predict(model.lm, credit.test)
model.lm.summary <- summary(model.lm)
model.lm$results
model.ridge <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.ridge$results
library(caret)
library(dplyr)
source("code/functions/evaluation.R")
# import preprocessed credit file
credit <- read.csv("data/scaled-credit.csv")
# split data set into 80% (training & validation) / 20% (testing)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
set.seed(1000)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
library(caret)
library(dplyr)
source("code/functions/evaluation.R")
# import preprocessed credit file
credit <- read.csv("data/scaled-credit.csv")
# split data set into 80% (training & validation) / 20% (testing)
set.seed(1000)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
# train the model
model.lasso <- train(Balance~., data=credit.train, trControl=train_control, method="lasso")
model.lasso$results
credit.test %>% nrow()
credit.train %>% nrow()
?glmnet
glmnet
install.packages("glmnet")
library(glmnet)
?glmnet()
select(credit.train, -Balance)
head(select(credit.train, -Balance))
glmnet(select(credit.train, -Balance), credit.train$Balance, alpha = 0)
glmnet(select(credit.train, -Balance), credit.train$Balance, alpha = 0)
summary(credit.train)
str(credit.train)
str(credit.train)
glmnet(select(credit.train, -Balance), credit.train$Balance, alpha = 0)
glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0)
?cv.glmnet()
grid <- 10 ^ seq(10, -2, length = 100)
grid
grid
cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid)
model.ridge.cv <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid)
model.ridge.cv
model.ridge.cv
model.ridge.cv$lambda.min
glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.cv$lambda.min)
model.ridge2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.cv$lambda.min)
model.ridge2
predict(model.ridge2, credit.test)
plot(model.ridge.cv)
as.matrix(select(credit.train, -Balance))
as.matrix(select(credit.train, -Balance))
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid)
plot(model.ridge.lambda)
predLasso<-predict(model.ridge.lambda, as.matrix(select(credit.test, -Balance)) ,s="lambda.min")
predLasso
model.ridge.model <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
model.ridge.model
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid)
model.ridge.model2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
predict(model.ridge.model2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
model.ridge.lambda
model.ridge.lambda$lambda.min
predict(model.ridge2, credit.test, s= model.ridge.lambda$lambda.min)
model.ridge.lambda$lambda.min
model.ridge.lambda$lambda.min
predict(model.ridge2, as.matrix(select(credit.test, -Balance)), s= model.ridge.lambda$lambda.min)
predict(model.ridge2, as.matrix(select(credit.test, -Balance)), s= model.ridge.lambda$lambda.min) %>% nrow()
rsquared(credit.test$Balance, predict(model.ridge2, as.matrix(select(credit.test, -Balance)), s= model.ridge.lambda$lambda.min) %>% nrow())
nrow(credit.test$Balance)
credit.test$Balance
rsquared(credit.test$Balance, predict(model.ridge.model2, as.matrix(select(credit.test, -Balance)), s= model.ridge.lambda$lambda.min) %>% nrow())
library(caret)
library(dplyr)
library(glmnet)
source("code/functions/evaluation.R")
credit <- read.csv("data/scaled-credit.csv")
# import preprocessed credit file
# split data set into 80% (training & validation) / 20% (testing)
set.seed(1000)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
# train the model
model.ridge <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.ridge$results
set.seed(1000)
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid)
model.ridge.model2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
model.ridge.model2.pred <- predict(model.ridge.model2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
model.ridge.model2.pred
rsquared(credit.test$Balance, model.ridge.model2.pred)
model.ridge$results
set.seed(1000)
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid, alpha = 0)
model.ridge.model2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
model.ridge.model2.pred <- predict(model.ridge.model2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
rsquared(credit.test$Balance, model.ridge.model2.pred)
predict(model.ridge, credit.test$Balance)
model.ridge <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
predict(model.ridge, credit.test$Balance)
credit.test
head(credit.test)
predict(model.ridge, credit.test)
model.ridge.pred <- predict(model.ridge, credit.test)
rsquared(credit.test$Balance, model.ridge.pred)
SSE <- function(y, y_estimated) {
return(sum((y - y_estimated) ^ 2))
}
source("code/functions/evaluation.R")
rsquared(credit.test$Balance, model.ridge.pred)
rsquared(credit.test$Balance, model.ridge.model2.pred)
library(caret)
library(dplyr)
library(glmnet)
source("code/functions/evaluation.R")
# import preprocessed credit file
credit <- read.csv("data/scaled-credit.csv")
# split data set into 80% (training & validation) / 20% (testing)
set.seed(1000)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.test <- credit[-index, ]
credit.train <- credit[index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
# train the model
model.ridge <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.ridge$results
model.ridge.pred <- predict(model.ridge, credit.test)
rsquared(credit.test$Balance, model.ridge.pred)
set.seed(1000)
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid, alpha = 0)
model.ridge.model2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
model.ridge.model2.pred <- predict(model.ridge.model2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
rsquared(credit.test$Balance, model.ridge.model2.pred)
model.ridge1 <- train(Balance~., data=credit.train, trControl=train_control, method="ridge")
model.ridge1$results
model.ridge1.pred <- predict(model.ridge1, credit.test)
rsquared(credit.test$Balance, model.ridge1.pred)
set.seed(1000)
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid, alpha = 0)
model.ridge.model2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge.lambda$lambda.min)
model.ridge.model2.pred <- predict(model.ridge.model2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
rsquared(credit.test$Balance, model.ridge.model2.pred)
set.seed(1000)
grid <- 10 ^ seq(10, -2, length = 100)
model.ridge2.lambda <- cv.glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, nfolds = 10, intercept = FALSE, standardize = FALSE, lambda = grid, alpha = 0)
model.ridge2 <- glmnet(as.matrix(select(credit.train, -Balance)), credit.train$Balance, alpha = 0, lambda = model.ridge2.lambda$lambda.min)
model.ridge.model2.pred <- predict(model.ridge2,newx= as.matrix(select(credit.test, -Balance)),type="response",s=0.01)
rsquared(credit.test$Balance, model.ridge.model2.pred)
model.ridge2.lambda
model.ridge.model2.pred <- predict(model.ridge2,newx= as.matrix(select(credit.test, -Balance)),type="response",s= model.ridge2.lambda$lambda.min)
rsquared(credit.test$Balance, model.ridge.model2.pred)
model.ridge2.pred <- predict(model.ridge2,newx= as.matrix(select(credit.test, -Balance)),type="response",s= model.ridge2.lambda$lambda.min)
rsquared(credit.test$Balance, model.ridge2.pred)
install.packages("pls")
)
library(pls)
library(pls)
library(caret)
library(dplyr)
library(pls)
source("code/functions/evaluation.R")
model.ridge1 <- train(Balance~., data=credit.train, trControl=train_control, method="pcr")
model.pcr1 <- train(Balance~., data=credit.train, trControl=train_control, method="pcr")
model.pcr1$results
model.ridge1.pred <- predict(model.pcr1, credit.test)
model.ridge1.pred <- predict(model.pcr1, credit.test)
rsquared(credit.test$Balance, model.ridge1.pred)
model.pcr1 <- train(Balance~., data=credit.train, trControl=train_control, method="pcr")
model.pcr1$results
model.pcr1.pred <- predict(model.pcr1, credit.test)
rsquared(credit.test$Balance, model.pcr1)
model.pcr1
model.pcr1.pred <- predict(model.pcr1, credit.test)
model.pcr1.pred
rsquared(credit.test$Balance, model.pcr1.pred)
mse <- function(y, y_estimate) {
result = sum((y - y_estimate) ^ 2) / length(y)
return(result)
}
?pcr()
library(caret)
library(dplyr)
library(pls)
source("code/functions/evaluation.R")
# import preprocessed credit file
credit <- read.csv("data/scaled-credit.csv")
# split data set into 80% (training & validation) / 20% (testing)
set.seed(1000)
index <- createDataPartition(y = credit$Balance, p = 0.8, list = FALSE)
credit.train <- credit[index, ]
credit.test <- credit[-index, ]
# sanity check
credit.test %>% nrow()
credit.train %>% nrow()
# 10-fold cross validation
train_control<- trainControl(method="cv", number=10)
# train the model using caret
model.pcr1 <- train(Balance~., data=credit.train, trControl=train_control, method="pcr")
model.pcr1$results
# prediction using model.ridge1
model.pcr1.pred <- predict(model.pcr1, credit.test)
rsquared(credit.test$Balance, model.pcr1.pred)
pcr(Balance ~ ., data = credit.train, validation = 'CV')
model.pcr2 <- pcr(Balance ~ ., data = credit.train, ncomp = 3, validation = 'CV')
model.pcr2
pred.pcr <- predict(model.pcr2, ncomp = 1:6, newdata= credit.test)
model.pcr2 <- pcr(Balance ~ ., data = credit.train, ncomp = 3, validation = 'CV')
model.pcr2
model.pcr2
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test)
model.pcr2.pred
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2 <- pcr(Balance ~ ., data = credit.train, validation = 'CV')
# You can use the function validationplot(), with the argument val.type = "MSEP", on the outputs of pcr() and plsr().
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test)
model.pcr2.pred
model.pcr2.pred
plot(model.pcr2)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test, comps = 3)
model.pcr2.pred
model.pcr2.pred
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test, comps = 3)
model.pcr2.pred
model.pcr2.pred
model.pcr2 <- pcr(Balance ~ ., data = credit.train, validation = 'CV')
# You can use the function validationplot(), with the argument val.type = "MSEP", on the outputs of pcr() and plsr().
plot(model.pcr2)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test, comps = 3)
rsquared(credit.test$Balance, model.pcr2.pred)
?pcr
model.pcr2 <- pcr(Balance ~ ., ncomp = 3, data = credit.train, validation = 'CV')
# You can use the function validationplot(), with the argument val.type = "MSEP", on the outputs of pcr() and plsr().
plot(model.pcr2)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test, comps = 3)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2 <- pcr(Balance ~ ., ncomp = 3, data = credit.train, validation = 'CV', scale = FALSE)
# You can use the function validationplot(), with the argument val.type = "MSEP", on the outputs of pcr() and plsr().
plot(model.pcr2)
model.pcr2.pred <- predict(model.pcr2, newdata= credit.test, comps = 3)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2 <- pcr(Balance ~ ., data = credit.train, validation = 'CV', scale = FALSE)
model.pcr2$validation$PRESS
credit.train
credit.train
model.pcr2 <- pcr(Balance ~ ., data = credit.train, validation = 'CV', scale = FALSE)
model.pcr2
model.pcr2$validation$PRESS
summary(model.pcr2)
plot(model.pcr2)
plot(model.pcr2$ncomp)
plot(model.pcr2$loadings)
validationplot(model.pcr2, val.type = "MSEP")
summary(model.pcr2)
plot(summary(model.pcr2))
summary(model.pcr2)
plot(RMSEP(model.pcr2), legendpos = "topright")
plot(RMSEP(model.pcr2), legendpos = "topright")
summary(model.pcr2)
plot(RMSEP(model.pcr2), legendpos = "topright")
validationplot(model.pcr2, val.type = "MSEP")
plot(RMSEP(model.pcr2), legendpos = "topright")
plot(model.pcr2, plottype = "scores", comps = 1:3)
model.pcr2.pred <- predict(model.pcr2, ncomp = 2, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
rsquared(credit.test$Balance, model.pcr1.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 3, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 1, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 2, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 3, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 4, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 4, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 5, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 6, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 7, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 8, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 9, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 10, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2
model.pcr2
summary(model.pcr2)
model.pcr2.pred <- predict(model.pcr2, ncomp = 8, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 11, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
model.pcr2.pred <- predict(model.pcr2, ncomp = 9, newdata = credit.test)
rsquared(credit.test$Balance, model.pcr2.pred)
plot(model.pcr2$loadings)
plot(RMSEP(model.pcr2), legendpos = "topright")
plot(model.pcr2, plottype = "scores", comps = 1:3)
